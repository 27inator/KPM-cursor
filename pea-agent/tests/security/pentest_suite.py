#!/usr/bin/env python3
"""
KMP PEA Agent Security & Penetration Testing Suite

Comprehensive security testing including:
- Binary analysis and reverse engineering protection
- Network security and protocol testing
- Cryptographic implementation validation
- Privilege escalation testing
- Input validation and fuzzing
- Side-channel attack resistance
"""

import asyncio
import hashlib
import math
import json
import os
import platform
import random
import socket
import ssl
import subprocess
import sys
import tempfile
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
import requests
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ed25519
import psutil

@dataclass
class SecurityTestResult:
    name: str
    category: str
    severity: str  # "critical", "high", "medium", "low", "info"
    success: bool
    details: Dict[str, Any]
    recommendations: List[str]
    error: Optional[str] = None

class PEAAgentSecurityTester:
    """Comprehensive security tester for PEA Agent"""
    
    def __init__(self, agent_binary: str, config_file: str = None):
        self.agent_binary = agent_binary
        self.config_file = config_file
        self.test_results: List[SecurityTestResult] = []
        self.temp_dir = tempfile.mkdtemp(prefix="pea_security_test_")
        
    async def run_security_tests(self) -> Dict[str, Any]:
        """Run comprehensive security test suite"""
        print("🔒 Starting KMP PEA Agent Security Test Suite")
        print("=" * 60)
        
        start_time = time.time()
        
        try:
            # Binary security analysis
            await self.test_binary_security()
            await self.test_binary_protections()
            
            # Cryptographic security
            await self.test_cryptographic_implementation()
            await self.test_key_management_security()
            
            # Network security
            await self.test_network_security()
            await self.test_tls_configuration()
            
            # Input validation and fuzzing
            await self.test_input_validation()
            await self.test_command_injection()
            
            # Privilege and access control
            await self.test_privilege_escalation()
            await self.test_file_permissions()
            
            # Side-channel attacks
            await self.test_timing_attacks()
            await self.test_memory_leaks()
            
            # Configuration security
            await self.test_configuration_security()
            await self.test_secrets_handling()
            
        except Exception as e:
            print(f"❌ Security test suite failed with error: {e}")
        
        total_time = time.time() - start_time
        return self.generate_security_report(total_time)
    
    async def test_binary_security(self) -> SecurityTestResult:
        """Test binary security features and protections"""
        try:
            details = {}
            recommendations = []
            
            # Check if binary exists
            if not os.path.exists(self.agent_binary):
                raise FileNotFoundError(f"Binary not found: {self.agent_binary}")
            
            # Get binary information
            stat_info = os.stat(self.agent_binary)
            details["file_size"] = stat_info.st_size
            details["permissions"] = oct(stat_info.st_mode)
            
            # Check binary format and architecture
            file_output = await self.run_command(["file", self.agent_binary])
            details["file_type"] = file_output.stdout.decode().strip()
            
            # Check for security features (Linux/macOS)
            if platform.system() in ["Linux", "Darwin"]:
                # Check for stack canaries, NX bit, PIE, RELRO
                security_features = await self.check_binary_hardening()
                details.update(security_features)
                
                if not security_features.get("stack_canary", False):
                    recommendations.append("Enable stack canaries (-fstack-protector-strong)")
                if not security_features.get("nx_bit", False):
                    recommendations.append("Enable NX bit (non-executable stack)")
                if not security_features.get("pie", False):
                    recommendations.append("Enable Position Independent Executable (PIE)")
                if not security_features.get("relro", False):
                    recommendations.append("Enable RELRO (Relocation Read-Only)")
            
            # Check for debug symbols
            nm_output = await self.run_command(["nm", "-D", self.agent_binary])
            has_symbols = nm_output.returncode == 0 and len(nm_output.stdout) > 0
            details["debug_symbols"] = has_symbols
            
            if has_symbols:
                recommendations.append("Strip debug symbols from production binaries")
            
            # Calculate binary hash for integrity
            with open(self.agent_binary, 'rb') as f:
                binary_hash = hashlib.sha256(f.read()).hexdigest()
            details["sha256_hash"] = binary_hash
            
            severity = "medium" if recommendations else "low"
            
            result = SecurityTestResult(
                name="Binary Security Analysis",
                category="Binary Security",
                severity=severity,
                success=True,
                details=details,
                recommendations=recommendations
            )
            
        except Exception as e:
            result = SecurityTestResult(
                name="Binary Security Analysis",
                category="Binary Security",
                severity="high",
                success=False,
                details={},
                recommendations=["Fix binary security analysis errors"],
                error=str(e)
            )
        
        self.test_results.append(result)
        self.print_security_result(result)
        return result
    
    async def test_binary_protections(self) -> SecurityTestResult:
        """Test anti-reverse engineering and tampering protections"""
        try:
            details = {}
            recommendations = []
            
            # Check for code signing (macOS/Windows)
            if platform.system() == "Darwin":
                codesign_output = await self.run_command(["codesign", "-dv", self.agent_binary])
                is_signed = codesign_output.returncode == 0
                details["code_signed"] = is_signed
                
                if not is_signed:
                    recommendations.append("Code sign binary for macOS distribution")
            
            elif platform.system() == "Windows":
                # Check for Authenticode signature
                # This would require Windows-specific tools
                details["code_signed"] = "not_tested_on_linux"
            
            # Check for anti-debugging measures
            strings_output = await self.run_command(["strings", self.agent_binary])
            strings_content = strings_output.stdout.decode().lower()
            
            debug_strings = ["debug", "gdb", "lldb", "ptrace", "debugger"]
            found_debug_refs = [s for s in debug_strings if s in strings_content]
            details["debug_references"] = found_debug_refs
            
            if found_debug_refs:
                recommendations.append("Remove or obfuscate debug-related strings")
            
            # Check for hardcoded secrets or keys
            suspicious_patterns = ["password", "secret", "key", "token", "api"]
            found_patterns = [p for p in suspicious_patterns if p in strings_content]
            details["suspicious_strings"] = found_patterns
            
            if found_patterns:
                recommendations.append("Ensure no hardcoded secrets in binary")
                severity = "high"
            else:
                severity = "low"
            
            result = SecurityTestResult(
                name="Binary Protection Analysis",
                category="Binary Security",
                severity=severity,
                success=True,
                details=details,
                recommendations=recommendations
            )
            
        except Exception as e:
            result = SecurityTestResult(
                name="Binary Protection Analysis",
                category="Binary Security",
                severity="medium",
                success=False,
                details={},
                recommendations=["Review binary protection mechanisms"],
                error=str(e)
            )
        
        self.test_results.append(result)
        self.print_security_result(result)
        return result
    
    async def test_cryptographic_implementation(self) -> SecurityTestResult:
        """Test cryptographic implementation security"""
        try:
            details = {}
            recommendations = []
            
            # Test Ed25519 key generation
            private_key = ed25519.Ed25519PrivateKey.generate()
            public_key = private_key.public_key()
            
            # Test signing and verification
            message = b"security test message"
            signature = private_key.sign(message)
            
            # Verify signature
            try:
                public_key.verify(signature, message)
                details["ed25519_verification"] = True
            except Exception:
                details["ed25519_verification"] = False
                recommendations.append("Fix Ed25519 signature verification")
            
            # Test key serialization
            private_bytes = private_key.private_bytes(
                encoding=serialization.Encoding.Raw,
                format=serialization.PrivateFormat.Raw,
                encryption_algorithm=serialization.NoEncryption()
            )
            
            public_bytes = public_key.public_bytes(
                encoding=serialization.Encoding.Raw,
                format=serialization.PublicFormat.Raw
            )
            
            details["private_key_size"] = len(private_bytes)
            details["public_key_size"] = len(public_bytes)
            
            if len(private_bytes) != 32:
                recommendations.append("Ed25519 private key should be 32 bytes")
            if len(public_bytes) != 32:
                recommendations.append("Ed25519 public key should be 32 bytes")
            
            # Test signature size
            details["signature_size"] = len(signature)
            if len(signature) != 64:
                recommendations.append("Ed25519 signature should be 64 bytes")
            
            # Test entropy quality (basic check)
            entropy_test = self.test_entropy_quality(private_bytes)
            details.update(entropy_test)
            
            if not entropy_test.get("good_entropy", True):
                recommendations.append("Improve entropy source for key generation")
            
            severity = "high" if recommendations else "low"
            
            result = SecurityTestResult(
                name="Cryptographic Implementation",
                category="Cryptography",
                severity=severity,
                success=True,
                details=details,
                recommendations=recommendations
            )
            
        except Exception as e:
            result = SecurityTestResult(
                name="Cryptographic Implementation",
                category="Cryptography",
                severity="critical",
                success=False,
                details={},
                recommendations=["Fix cryptographic implementation errors"],
                error=str(e)
            )
        
        self.test_results.append(result)
        self.print_security_result(result)
        return result
    
    async def test_key_management_security(self) -> SecurityTestResult:
        """Test key management and storage security"""
        try:
            details = {}
            recommendations = []
            
            # Test secure memory handling
            # This is a basic test - real implementation would be more sophisticated
            test_key = os.urandom(32)
            
            # Test that keys are properly zeroized
            # In a real implementation, this would test actual memory clearing
            details["secure_memory_test"] = "basic_test_passed"
            
            # Test key derivation (HKDF simulation)
            import hmac
            
            master_key = os.urandom(32)
            salt = os.urandom(16)
            info = b"PEA Agent Key Derivation"
            
            # Simple HKDF extract-expand
            prk = hmac.new(salt, master_key, hashlib.sha256).digest()
            derived_key = hmac.new(prk, info + b"\x01", hashlib.sha256).digest()
            
            details["hkdf_test"] = len(derived_key) == 32
            
            if not details["hkdf_test"]:
                recommendations.append("Fix HKDF key derivation implementation")
            
            # Test key rotation simulation
            old_key = os.urandom(32)
            new_key = os.urandom(32)
            
            # Keys should be different
            keys_different = old_key != new_key
            details["key_rotation_test"] = keys_different
            
            if not keys_different:
                recommendations.append("Ensure key rotation generates different keys")
            
            # Test key storage permissions (basic check)
            if platform.system() != "Windows":
                # Check that key files would have proper permissions (600)
                test_file = os.path.join(self.temp_dir, "test_key")
                with open(test_file, 'wb') as f:
                    f.write(test_key)
                
                os.chmod(test_file, 0o600)
                stat_info = os.stat(test_file)
                permissions = oct(stat_info.st_mode)[-3:]
                
                details["key_file_permissions"] = permissions
                
                if permissions != "600":
                    recommendations.append("Set key files to 600 permissions (owner read/write only)")
            
            severity = "medium" if recommendations else "low"
            
            result = SecurityTestResult(
                name="Key Management Security",
                category="Cryptography",
                severity=severity,
                success=True,
                details=details,
                recommendations=recommendations
            )
            
        except Exception as e:
            result = SecurityTestResult(
                name="Key Management Security",
                category="Cryptography",
                severity="high",
                success=False,
                details={},
                recommendations=["Review key management security"],
                error=str(e)
            )
        
        self.test_results.append(result)
        self.print_security_result(result)
        return result
    
    async def test_network_security(self) -> SecurityTestResult:
        """Test network security and protocol implementation"""
        try:
            details = {}
            recommendations = []
            
            # Test TLS configuration
            test_endpoints = [
                "provision.kmp.io:443",
                "monitor.kmp.io:443",
                "n-testnet-10.kaspa.ws:16210"
            ]
            
            for endpoint in test_endpoints:
                host, port = endpoint.split(':')
                port = int(port)
                
                try:
                    # Test connection
                    sock = socket.create_connection((host, port), timeout=5)
                    
                    if port == 443:
                        # Test TLS for HTTPS endpoints
                        context = ssl.create_default_context()
                        with context.wrap_socket(sock, server_hostname=host) as ssock:
                            cert = ssock.getpeercert()
                            tls_version = ssock.version()
                            cipher = ssock.cipher()
                            
                            details[f"{host}_tls_version"] = tls_version
                            details[f"{host}_cipher"] = cipher[0] if cipher else "unknown"
                            
                            # Check TLS version
                            if tls_version and tls_version < "TLSv1.2":
                                recommendations.append(f"Upgrade TLS version for {host}")
                    else:
                        # Test raw connection for Kaspa RPC
                        details[f"{host}_connection"] = "success"
                    
                    sock.close()
                    
                except Exception as e:
                    details[f"{host}_error"] = str(e)
            
            # Test certificate validation
            # This would be more comprehensive in a real implementation
            details["certificate_validation"] = "basic_test"
            
            # Test for common network vulnerabilities
            # Check for weak cipher suites, protocol downgrade, etc.
            weak_ciphers = ["RC4", "DES", "3DES", "MD5"]
            for endpoint, cipher in details.items():
                if endpoint.endswith("_cipher") and any(weak in str(cipher) for weak in weak_ciphers):
                    recommendations.append(f"Weak cipher detected: {cipher}")
            
            severity = "medium" if recommendations else "low"
            
            result = SecurityTestResult(
                name="Network Security",
                category="Network",
                severity=severity,
                success=True,
                details=details,
                recommendations=recommendations
            )
            
        except Exception as e:
            result = SecurityTestResult(
                name="Network Security",
                category="Network",
                severity="medium",
                success=False,
                details={},
                recommendations=["Review network security configuration"],
                error=str(e)
            )
        
        self.test_results.append(result)
        self.print_security_result(result)
        return result
    
    async def test_input_validation(self) -> SecurityTestResult:
        """Test input validation and sanitization"""
        try:
            details = {}
            recommendations = []
            
            # Test command line argument injection
            malicious_inputs = [
                "--config=/etc/passwd",
                "--config='; rm -rf / #'",
                "--config=$(whoami)",
                "--config=`id`",
                "--config=../../../etc/passwd",
                "--config=" + "A" * 10000,  # Buffer overflow attempt
                "--config=\x00\x01\x02\x03",  # Null bytes and control chars
            ]
            
            for i, malicious_input in enumerate(malicious_inputs):
                try:
                    # Test if agent handles malicious input gracefully
                    result = await self.run_command([self.agent_binary, "status", malicious_input], timeout=5)
                    
                    # Agent should reject invalid input, not crash
                    if result.returncode != 0:
                        details[f"malicious_input_{i}"] = "rejected"
                    else:
                        details[f"malicious_input_{i}"] = "accepted"
                        recommendations.append(f"Improve input validation for: {malicious_input[:50]}")
                
                except Exception as e:
                    # Timeouts or crashes indicate poor input handling
                    details[f"malicious_input_{i}"] = f"error: {str(e)[:100]}"
                    recommendations.append("Fix input validation to prevent crashes")
            
            # Test configuration file parsing
            malicious_configs = [
                "malicious: $(whoami)",
                "config:\n  - !python/object/apply:os.system ['rm -rf /']",  # YAML deserialization
                "x" * 100000,  # Large input
                "\x00\x01\x02invalid",  # Binary data
            ]
            
            for i, config_content in enumerate(malicious_configs):
                config_file = os.path.join(self.temp_dir, f"malicious_config_{i}.yaml")
                
                try:
                    with open(config_file, 'w') as f:
                        f.write(config_content)
                    
                    # Test config parsing
                    result = await self.run_command([
                        self.agent_binary, "config", "--validate", "--config", config_file
                    ], timeout=5)
                    
                    details[f"malicious_config_{i}"] = "parsed" if result.returncode == 0 else "rejected"
                    
                except Exception as e:
                    details[f"malicious_config_{i}"] = f"error: {str(e)[:100]}"
            
            # Count how many malicious inputs were properly rejected
            rejected_count = sum(1 for v in details.values() if "rejected" in str(v))
            total_count = len(details)
            
            details["input_validation_score"] = f"{rejected_count}/{total_count}"
            
            if rejected_count < total_count * 0.8:  # Less than 80% rejection rate
                severity = "high"
                recommendations.append("Improve overall input validation")
            elif recommendations:
                severity = "medium"
            else:
                severity = "low"
            
            result = SecurityTestResult(
                name="Input Validation",
                category="Input Security",
                severity=severity,
                success=True,
                details=details,
                recommendations=recommendations
            )
            
        except Exception as e:
            result = SecurityTestResult(
                name="Input Validation",
                category="Input Security",
                severity="high",
                success=False,
                details={},
                recommendations=["Fix input validation testing errors"],
                error=str(e)
            )
        
        self.test_results.append(result)
        self.print_security_result(result)
        return result
    
    async def test_privilege_escalation(self) -> SecurityTestResult:
        """Test for privilege escalation vulnerabilities"""
        try:
            details = {}
            recommendations = []
            
            # Check current process privileges
            if platform.system() != "Windows":
                uid = os.getuid()
                gid = os.getgid()
                
                details["current_uid"] = uid
                details["current_gid"] = gid
                details["running_as_root"] = uid == 0
                
                if uid == 0:
                    recommendations.append("Avoid running as root in production")
                    severity = "medium"
                else:
                    severity = "low"
                
                # Check for SUID/SGID bits
                stat_info = os.stat(self.agent_binary)
                mode = stat_info.st_mode
                
                has_suid = bool(mode & 0o4000)
                has_sgid = bool(mode & 0o2000)
                
                details["suid_bit"] = has_suid
                details["sgid_bit"] = has_sgid
                
                if has_suid or has_sgid:
                    recommendations.append("Remove SUID/SGID bits unless absolutely necessary")
                    severity = "high"
            
            # Test file creation in sensitive directories
            sensitive_dirs = ["/etc", "/usr/bin", "/usr/sbin", "/root"]
            
            for dir_path in sensitive_dirs:
                if os.path.exists(dir_path):
                    test_file = os.path.join(dir_path, f"pea_test_{random.randint(1000, 9999)}")
                    
                    try:
                        with open(test_file, 'w') as f:
                            f.write("test")
                        
                        # If we can create files, that's concerning
                        details[f"can_write_{dir_path}"] = True
                        recommendations.append(f"Should not be able to write to {dir_path}")
                        
                        # Clean up
                        os.remove(test_file)
                        
                    except PermissionError:
                        details[f"can_write_{dir_path}"] = False
                    except Exception as e:
                        details[f"write_test_{dir_path}"] = str(e)
            
            # Test capability to bind to privileged ports
            if platform.system() != "Windows":
                try:
                    test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    test_socket.bind(('localhost', 80))  # Privileged port
                    test_socket.close()
                    
                    details["can_bind_privileged_port"] = True
                    recommendations.append("Should not be able to bind to privileged ports")
                    
                except PermissionError:
                    details["can_bind_privileged_port"] = False
                except Exception as e:
                    details["privileged_port_test"] = str(e)
            
            result = SecurityTestResult(
                name="Privilege Escalation",
                category="Access Control",
                severity=severity,
                success=True,
                details=details,
                recommendations=recommendations
            )
            
        except Exception as e:
            result = SecurityTestResult(
                name="Privilege Escalation",
                category="Access Control",
                severity="medium",
                success=False,
                details={},
                recommendations=["Review privilege escalation tests"],
                error=str(e)
            )
        
        self.test_results.append(result)
        self.print_security_result(result)
        return result
    
    async def test_timing_attacks(self) -> SecurityTestResult:
        """Test resistance to timing attacks"""
        try:
            details = {}
            recommendations = []
            
            # Test timing consistency for cryptographic operations
            # This is a simplified test - real timing attack testing is more complex
            
            # Generate test keys
            private_key = ed25519.Ed25519PrivateKey.generate()
            
            # Test signing timing consistency
            message = b"timing test message"
            times = []
            
            for _ in range(100):
                start_time = time.perf_counter()
                signature = private_key.sign(message)
                end_time = time.perf_counter()
                times.append(end_time - start_time)
            
            # Calculate timing statistics
            avg_time = sum(times) / len(times)
            min_time = min(times)
            max_time = max(times)
            variance = sum((t - avg_time) ** 2 for t in times) / len(times)
            
            details["signing_avg_time"] = avg_time
            details["signing_min_time"] = min_time
            details["signing_max_time"] = max_time
            details["signing_variance"] = variance
            
            # Check for excessive timing variation
            time_ratio = max_time / min_time if min_time > 0 else 0
            details["timing_ratio"] = time_ratio
            
            if time_ratio > 2.0:  # More than 2x variation might indicate timing issues
                recommendations.append("Review cryptographic operations for timing consistency")
                severity = "medium"
            else:
                severity = "low"
            
            # Test verification timing consistency
            verify_times = []
            public_key = private_key.public_key()
            
            for _ in range(50):
                start_time = time.perf_counter()
                try:
                    public_key.verify(signature, message)
                except Exception:
                    pass
                end_time = time.perf_counter()
                verify_times.append(end_time - start_time)
            
            verify_avg = sum(verify_times) / len(verify_times)
            verify_variance = sum((t - verify_avg) ** 2 for t in verify_times) / len(verify_times)
            
            details["verify_avg_time"] = verify_avg
            details["verify_variance"] = verify_variance
            
            result = SecurityTestResult(
                name="Timing Attack Resistance",
                category="Side-Channel",
                severity=severity,
                success=True,
                details=details,
                recommendations=recommendations
            )
            
        except Exception as e:
            result = SecurityTestResult(
                name="Timing Attack Resistance",
                category="Side-Channel",
                severity="medium",
                success=False,
                details={},
                recommendations=["Review timing attack resistance"],
                error=str(e)
            )
        
        self.test_results.append(result)
        self.print_security_result(result)
        return result
    
    def test_entropy_quality(self, data: bytes) -> Dict[str, Any]:
        """Test entropy quality of random data"""
        if len(data) == 0:
            return {"good_entropy": False, "error": "no_data"}
        
        # Simple entropy tests
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        # Calculate Shannon entropy
        entropy = 0
        for count in byte_counts:
            if count > 0:
                p = count / len(data)
                entropy -= p * math.log2(p)  # Fixed: use math.log2() instead of bit_length()
        
        max_entropy = 8.0  # Maximum entropy for bytes
        entropy_ratio = entropy / max_entropy
        
        return {
            "entropy": entropy,
            "entropy_ratio": entropy_ratio,
            "good_entropy": entropy_ratio > 0.9,  # At least 90% of maximum entropy
            "data_length": len(data)
        }
    
    async def check_binary_hardening(self) -> Dict[str, bool]:
        """Check binary hardening features (Linux/macOS)"""
        features = {}
        
        try:
            # Check for stack canaries
            readelf_output = await self.run_command(["readelf", "-s", self.agent_binary])
            has_canary = "__stack_chk_fail" in readelf_output.stdout.decode()
            features["stack_canary"] = has_canary
        except:
            features["stack_canary"] = False
        
        try:
            # Check for NX bit (non-executable stack)
            readelf_output = await self.run_command(["readelf", "-l", self.agent_binary])
            output = readelf_output.stdout.decode()
            has_nx = "GNU_STACK" in output and "RWE" not in output
            features["nx_bit"] = has_nx
        except:
            features["nx_bit"] = False
        
        try:
            # Check for PIE (Position Independent Executable)
            readelf_output = await self.run_command(["readelf", "-h", self.agent_binary])
            output = readelf_output.stdout.decode()
            has_pie = "DYN" in output or "EXEC" not in output
            features["pie"] = has_pie
        except:
            features["pie"] = False
        
        try:
            # Check for RELRO
            readelf_output = await self.run_command(["readelf", "-l", self.agent_binary])
            output = readelf_output.stdout.decode()
            has_relro = "GNU_RELRO" in output
            features["relro"] = has_relro
        except:
            features["relro"] = False
        
        return features
    
    async def run_command(self, cmd: List[str], timeout: int = 30) -> subprocess.CompletedProcess:
        """Run command with timeout"""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), 
                timeout=timeout
            )
            
            return subprocess.CompletedProcess(
                args=cmd,
                returncode=process.returncode,
                stdout=stdout,
                stderr=stderr
            )
            
        except asyncio.TimeoutError:
            raise Exception(f"Command timed out after {timeout}s: {' '.join(cmd)}")
    
    def print_security_result(self, result: SecurityTestResult):
        """Print formatted security test result"""
        severity_colors = {
            "critical": "🔴",
            "high": "🟠", 
            "medium": "🟡",
            "low": "🟢",
            "info": "🔵"
        }
        
        color = severity_colors.get(result.severity, "⚪")
        status = "✅ PASS" if result.success else "❌ FAIL"
        
        print(f"{color} {status} {result.name} ({result.severity.upper()})")
        
        if result.error:
            print(f"    Error: {result.error}")
        
        if result.recommendations:
            print("    Recommendations:")
            for rec in result.recommendations[:3]:  # Show first 3 recommendations
                print(f"      • {rec}")
    
    def generate_security_report(self, total_time: float) -> Dict[str, Any]:
        """Generate comprehensive security report"""
        # Categorize results
        categories = {}
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        
        for result in self.test_results:
            if result.category not in categories:
                categories[result.category] = []
            categories[result.category].append(result)
            
            severity_counts[result.severity] += 1
        
        # Calculate security score
        total_tests = len(self.test_results)
        passed_tests = sum(1 for r in self.test_results if r.success)
        
        # Weight by severity
        security_score = 0
        max_score = 0
        
        for result in self.test_results:
            weight = {"critical": 10, "high": 7, "medium": 4, "low": 2, "info": 1}[result.severity]
            max_score += weight
            if result.success:
                security_score += weight
        
        security_percentage = (security_score / max_score * 100) if max_score > 0 else 0
        
        # Generate recommendations summary
        all_recommendations = []
        for result in self.test_results:
            all_recommendations.extend(result.recommendations)
        
        report = {
            "summary": {
                "total_tests": total_tests,
                "passed_tests": passed_tests,
                "security_score": round(security_percentage, 1),
                "severity_counts": severity_counts,
                "total_time": round(total_time, 2)
            },
            "categories": {
                cat: len(results) for cat, results in categories.items()
            },
            "recommendations": list(set(all_recommendations))[:10],  # Top 10 unique recommendations
            "detailed_results": [
                {
                    "name": r.name,
                    "category": r.category,
                    "severity": r.severity,
                    "success": r.success,
                    "details": r.details,
                    "recommendations": r.recommendations,
                    "error": r.error
                }
                for r in self.test_results
            ]
        }
        
        # Print summary
        print("\n" + "=" * 60)
        print("🔒 Security Test Results")
        print("=" * 60)
        print(f"🛡️  Security Score: {security_percentage:.1f}%")
        print(f"📊 Tests: {passed_tests}/{total_tests} passed")
        print(f"⚠️  Critical: {severity_counts['critical']}, High: {severity_counts['high']}, Medium: {severity_counts['medium']}")
        print(f"⏱️  Total Time: {total_time:.2f}s")
        
        if security_percentage >= 90:
            print("🎉 Excellent security posture!")
        elif security_percentage >= 75:
            print("✅ Good security, minor improvements needed")
        elif security_percentage >= 60:
            print("⚠️  Moderate security, several issues to address")
        else:
            print("❌ Security concerns require immediate attention")
        
        return report

async def main():
    """Main entry point for security tests"""
    import argparse
    
    parser = argparse.ArgumentParser(description="KMP PEA Agent Security Test Suite")
    parser.add_argument("agent_binary", help="Path to PEA agent binary")
    parser.add_argument("--config", help="Configuration file to use")
    parser.add_argument("--output", help="Output file for security report (JSON)")
    
    args = parser.parse_args()
    
    if not os.path.exists(args.agent_binary):
        print(f"❌ Agent binary not found: {args.agent_binary}")
        sys.exit(1)
    
    tester = PEAAgentSecurityTester(args.agent_binary, args.config)
    report = await tester.run_security_tests()
    
    # Save report if requested
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(report, f, indent=2)
        print(f"📄 Security report saved to: {args.output}")
    
    # Exit with appropriate code based on security score
    security_score = report["summary"]["security_score"]
    if security_score >= 90:
        sys.exit(0)  # Excellent
    elif security_score >= 75:
        sys.exit(1)  # Good but needs improvement
    elif security_score >= 60:
        sys.exit(2)  # Moderate issues
    else:
        sys.exit(3)  # Serious security concerns

if __name__ == "__main__":
    asyncio.run(main()) 